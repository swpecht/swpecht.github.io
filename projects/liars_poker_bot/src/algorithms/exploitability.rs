use itertools::Itertools;

use crate::{
    actions,
    algorithms::tabular_best_response::TabularBestResponse,
    cfragent::cfrnode::ActionVec,
    game::{
        kuhn_poker::{KPAction, KPGameState},
        Action, Game, GameState,
    },
    policy::Policy,
};

pub struct ExploitabilityData {
    pub nash_conv: f64,
    pub player_improvements: Vec<f64>,
}

/// Value of a state for every player given a policy.
fn state_values<G: GameState, P: Policy<G>>(
    state: &mut G,
    num_players: usize,
    policy: &mut P,
) -> Vec<f64> {
    if state.is_terminal() {
        return (0..num_players).map(|p| state.evaluate(p)).collect_vec();
    }

    let actions = actions!(state);
    let probs = match state.is_chance_node() {
        true => uniform_action_probs(&actions),
        false => policy.action_probabilities(state),
    };

    let mut v = vec![0.0; num_players];

    for a in actions {
        state.apply_action(a);
        let action_values = state_values(state, num_players, policy);
        state.undo();
        for p in 0..num_players {
            v[p] += probs[a] * action_values[p];
        }
    }
    v
}

/// Return an action vec of uniform probailities
fn uniform_action_probs(actions: &Vec<Action>) -> ActionVec<f64> {
    let mut v = ActionVec::new(actions);
    let p = 1.0 / actions.len() as f64;

    for &a in actions {
        v[a] = p;
    }

    v
}

/// Returns the exploitability using the nash_conv method from openspeil
///
/// https://github.com/deepmind/open_spiel/blob/master/open_spiel/python/algorithms/exploitability.py
/// See https://arxiv.org/pdf/1711.00832.pdf for the NashConv definition.
pub fn exploitability<G: GameState, P: Policy<G>>(
    game: Game<G>,
    policy: &mut P,
) -> ExploitabilityData {
    let mut root_state = (game.new)();
    let num_players = root_state.num_players();
    if num_players != 2 {
        panic!("only support 2 players");
    }

    let mut best_response_values = Vec::new();
    for p in 0..root_state.num_players() {
        let mut br = TabularBestResponse::new(policy, &root_state, p, 0.0);
        best_response_values.push(br.value(&mut root_state.clone()));
    }

    let on_policy_values = state_values(&mut root_state, num_players, policy);
    let mut player_improvements = Vec::new();
    for i in 0..on_policy_values.len() {
        player_improvements.push(best_response_values[i] - on_policy_values[i]);
    }

    let nash_conv = player_improvements.iter().sum();

    ExploitabilityData {
        nash_conv,
        player_improvements,
    }
}

/// Policy for the nash equialibrium strategy of kuhn poker
///
/// https://en.wikipedia.org/wiki/Kuhn_poker
#[derive(Default)]
pub struct KuhnPokerNashPolicy {}
impl Policy<KPGameState> for KuhnPokerNashPolicy {
    fn action_probabilities(&mut self, gs: &KPGameState) -> ActionVec<f64> {
        assert!(!gs.is_chance_node());
        let istate = gs.istate_string(gs.cur_player());
        let bet_rate = match istate.as_str() {
            "Jack" => 1.0 / 3.0,
            "Jackb" => 0.0,
            "Jackp" => 1.0 / 3.0,
            "Jackpb" => 0.0,
            "King" => 1.0,
            "Kingb" => 1.0,
            "Kingp" => 1.0,
            "Kingpb" => 1.0,
            "Kingpbp" => 1.0,
            "Queen" => 0.0,
            "Queenp" => 0.0,
            "Queenpb" => 2.0 / 3.0,
            "Queenb" => 1.0 / 3.0,
            _ => panic!("invalid istate string: {}", istate),
        };

        let mut policy = ActionVec::new(&actions!(gs));

        policy[KPAction::Bet.into()] = bet_rate;
        policy[KPAction::Pass.into()] = 1.0 - bet_rate;

        policy
    }
}

#[cfg(test)]
mod tests {
    use approx::assert_relative_eq;

    use crate::{
        algorithms::exploitability::{exploitability, KuhnPokerNashPolicy},
        game::kuhn_poker::{KPAction, KuhnPoker},
        policy::{AlwaysPolicy, UniformRandomPolicy},
    };

    #[test]
    fn test_always_bet_exploitability() {
        let mut policy = AlwaysPolicy::new(KPAction::Bet.into());
        let data = exploitability(KuhnPoker::game(), &mut policy);

        // With no chance outcomes decided:
        // 1/3 chance get a 0 -- should immediately fold, ev = -1
        // 1/3 chance get a 1 -- should be neutral, 50% of time win and 50% lose, ev = 0
        // 1/3 chance get a 2 -- should bet, 100% win 2
        //
        // Total should be 1/3 * (0 + -1 + 2) = 1/3 for each player
        assert_relative_eq!(data.nash_conv, 2.0 / 3.0)
    }

    #[test]
    fn test_always_fold_exploitability() {
        let mut policy = AlwaysPolicy::new(KPAction::Pass.into());
        let data = exploitability(KuhnPoker::game(), &mut policy);

        // From openspeil tests: https://github.com/deepmind/open_spiel/blob/master/open_spiel/python/algorithms/exploitability_test.py
        assert_relative_eq!(data.nash_conv, 2.0)
    }

    #[test]
    fn test_uniform_exploitability() {
        let mut policy = UniformRandomPolicy::new();
        let data = exploitability(KuhnPoker::game(), &mut policy);
        assert_eq!(data.nash_conv, 11.0 / 12.0)
    }

    #[test]
    fn test_kuhn_poker_nash_exploitability() {
        let mut policy = KuhnPokerNashPolicy::default();
        let data = exploitability(KuhnPoker::game(), &mut policy);
        assert_relative_eq!(data.nash_conv, 0.0);
    }
}
