use itertools::Itertools;
use rand::{seq::SliceRandom, thread_rng};

use crate::{
    actions,
    algorithms::tabular_best_response::TabularBestResponse,
    cfragent::cfrnode::ActionVec,
    game::{Action, Game, GameState},
    policy::Policy,
};

pub struct ExploitabilityData {
    pub nash_conv: f64,
    pub player_improvements: Vec<f64>,
}

/// Value of a state for every player given a policy.
fn state_values<G: GameState, P: Policy<G>>(
    state: &G,
    num_players: usize,
    policy: &mut P,
) -> Vec<f64> {
    if state.is_terminal() {
        return (0..num_players).map(|p| state.evaluate(p)).collect_vec();
    }

    let actions = actions!(state);
    let probs = match state.is_chance_node() {
        true => uniform_action_probs(&actions),
        false => policy.action_probabilities(state),
    };

    let mut v = vec![0.0; num_players];

    for a in actions {
        let mut ngs = state.clone();
        ngs.apply_action(a);
        let action_values = state_values(&ngs, num_players, policy);
        for p in 0..num_players {
            v[p] += probs[a] * action_values[p];
        }
    }
    v
}

/// Return an action vec of uniform probailities
fn uniform_action_probs(actions: &Vec<Action>) -> ActionVec<f64> {
    let mut v = ActionVec::new(actions);
    let p = 1.0 / actions.len() as f64;

    for &a in actions {
        v[a] = p;
    }

    v
}

/// Returns the exploitability using the nash_conv method from openspeil
///
/// https://github.com/deepmind/open_spiel/blob/master/open_spiel/python/algorithms/exploitability.py
/// See https://arxiv.org/pdf/1711.00832.pdf for the NashConv definition.
pub fn exploitability<G: GameState, P: Policy<G>>(
    game: Game<G>,
    policy: &mut P,
) -> ExploitabilityData {
    let root_state = (game.new)();
    exploitability_from_state(root_state, policy)
}

fn exploitability_from_state<G: GameState, P: Policy<G>>(
    root_state: G,
    policy: &mut P,
) -> ExploitabilityData {
    if root_state.num_players() != 2 {
        panic!("only support 2 players");
    }

    let mut best_response_values = Vec::new();
    for p in 0..root_state.num_players() {
        let mut br = TabularBestResponse::new(policy, &root_state, p, 0.0);
        best_response_values.push(br.value(&root_state));
    }

    let on_policy_values = state_values(&root_state, root_state.num_players(), policy);
    let mut player_improvements = Vec::new();
    for i in 0..on_policy_values.len() {
        player_improvements.push(best_response_values[i] - on_policy_values[i]);
    }

    let nash_conv = player_improvements.iter().sum();

    ExploitabilityData {
        nash_conv,
        player_improvements,
    }
}

pub struct SampledExploitabilityData {
    pub nash_conv: f64,
    pub iterations: usize,
}

/// Estimates exploitability by choosing randomly at initial chance nodes and averages over the results
pub fn sampled_exploitability<G: GameState, P: Policy<G>>(
    game: Game<G>,
    policy: &mut P,
    iterations: usize,
) -> SampledExploitabilityData {
    let mut nash_conv_sum = 0.0;
    let ngf = game.new;

    for _ in 0..iterations {
        let mut gs = (ngf)();
        let mut actions = Vec::new();
        while gs.is_chance_node() {
            actions.clear();
            gs.legal_actions(&mut actions);
            let a = actions.choose(&mut thread_rng()).unwrap();
            gs.apply_action(*a);
        }

        nash_conv_sum += exploitability_from_state(gs, policy).nash_conv;
    }

    SampledExploitabilityData {
        nash_conv: nash_conv_sum / iterations as f64,
        iterations,
    }
}

#[cfg(test)]
mod tests {
    use approx::assert_relative_eq;

    use crate::{
        algorithms::exploitability::exploitability,
        game::kuhn_poker::{KPAction, KuhnPoker},
        policy::{AlwaysPolicy, UniformRandomPolicy},
    };

    use super::sampled_exploitability;

    #[test]
    fn test_always_bet_exploitability() {
        let mut policy = AlwaysPolicy::new(KPAction::Bet.into());
        let data = exploitability(KuhnPoker::game(), &mut policy);

        // With no chance outcomes decided:
        // 1/3 chance get a 0 -- should immediately fold, ev = -1
        // 1/3 chance get a 1 -- should be neutral, 50% of time win and 50% lose, ev = 0
        // 1/3 chance get a 2 -- should bet, 100% win 2
        //
        // Total should be 1/3 * (0 + -1 + 2) = 1/3 for each player
        assert_relative_eq!(data.nash_conv, 2.0 / 3.0)
    }

    #[test]
    fn test_always_fold_exploitability() {
        let mut policy = AlwaysPolicy::new(KPAction::Pass.into());
        let data = exploitability(KuhnPoker::game(), &mut policy);

        // From openspeil tests: https://github.com/deepmind/open_spiel/blob/master/open_spiel/python/algorithms/exploitability_test.py
        assert_relative_eq!(data.nash_conv, 2.0)
    }

    #[test]
    fn test_kuhn_poker_optimal_exploitability() {
        todo!();
    }

    #[test]
    fn test_uniform_exploitability() {
        let mut policy = UniformRandomPolicy::new();
        let data = exploitability(KuhnPoker::game(), &mut policy);
        assert_eq!(data.nash_conv, 11.0 / 12.0)
    }

    #[test]
    fn test_sample_expoitability_kuhn_poker() {
        let mut policy = UniformRandomPolicy::new();
        let data = exploitability(KuhnPoker::game(), &mut policy);
        let data_sampled = sampled_exploitability(KuhnPoker::game(), &mut policy, 1000);

        assert_relative_eq!(data_sampled.nash_conv, data.nash_conv);
    }
}
