use card_platypus::{
    algorithms::{
        exploitability::exploitability,
        ismcts::{
            ChildSelectionPolicy, ISMCTBotConfig, ISMCTSBot, ISMCTSFinalPolicyType,
            RandomRolloutEvaluator,
        },
        open_hand_solver::OpenHandSolver,
        pimcts::PIMCTSBot,
    },
    game::{bluff::Bluff, kuhn_poker::KuhnPoker},
    policy::UniformRandomPolicy,
};
use log::info;

use crate::{scripts::benchmark::get_rng, Args};

pub fn calcualte_agent_exploitability(_args: Args) {
    info!("calculating exploitability for kuhn poker...");
    let g = || (KuhnPoker::game().new)();

    let mut p = UniformRandomPolicy::new();
    let e = exploitability(g, &mut p).nash_conv;
    info!("Uniform random\t{}", e);

    // let mut p = PIMCTSBot::new(32, RandomRolloutEvaluator::new(10), get_rng());
    // let e = exploitability(g.clone(), &mut p).nash_conv;
    // info!("PIMCTS, random\t{}", e);

    let mut p = PIMCTSBot::new(32, OpenHandSolver::default(), get_rng());
    let e = exploitability(g, &mut p).nash_conv;
    info!("PIMCTS, open hand\t{}", e);

    let config = ISMCTBotConfig {
        child_selection_policy: ChildSelectionPolicy::Uct,
        final_policy_type: ISMCTSFinalPolicyType::MaxVisitCount,
        max_world_samples: -1, // unlimited samples
    };
    let mut p = ISMCTSBot::new(3.0, 500, OpenHandSolver::default(), config);
    let e = exploitability(g, &mut p).nash_conv;
    info!("ISMCTS, open hand\t{}", e);

    // let mut p = AlphaMuBot::new(OpenHandSolver::new(), 32, 1, get_rng());
    // let e = exploitability(g.clone(), &mut p).nash_conv;
    // info!("alpha mu, open hand, m=1\t{}", e);

    // let mut p = AlphaMuBot::new(OpenHandSolver::new(), 32, 10, get_rng());
    // let e = exploitability(g, &mut p).nash_conv;
    // info!("alpha mu, open hand, m=10\t{}", e);

    // let mut agent = CFRAgent::new(
    //     g.clone(),
    //     42,
    //     MemoryNodeStore::default(),
    //     CFRAlgorithm::CFRCS,
    // );
    // agent.train(100_000);
    // let e = exploitability(g, &mut agent.ns).nash_conv;
    // info!("cfr\t{}", e);

    info!("calculating exploitability for bluff 1,1...");
    let g = || (Bluff::game(1, 1).new)();

    let mut p = UniformRandomPolicy::new();
    let e = exploitability(g, &mut p).nash_conv;
    info!("Uniform random\t{}", e);

    // this needs to be done on se-sampled states, otherwise we're looking at the known information
    // instead have PIMCTSbot take random rollout as an evaluator
    let mut p = PIMCTSBot::new(100, RandomRolloutEvaluator::new(10), get_rng());
    let e = exploitability(g, &mut p).nash_conv;
    info!("PIMCTS, random\t{}", e);

    let mut p = PIMCTSBot::new(100, OpenHandSolver::default(), get_rng());
    let e = exploitability(g, &mut p).nash_conv;
    info!("PIMCTS, open hand\t{}", e);

    let config = ISMCTBotConfig {
        child_selection_policy: ChildSelectionPolicy::Uct,
        final_policy_type: ISMCTSFinalPolicyType::MaxVisitCount,
        max_world_samples: -1, // unlimited samples
    };
    let mut p = ISMCTSBot::new(3.0, 500, OpenHandSolver::default(), config);
    let e = exploitability(g, &mut p).nash_conv;
    info!("ISMCTS, open hand\t{}", e);

    // let mut p = AlphaMuBot::new(OpenHandSolver::new(), 32, 1, get_rng());
    // let e = exploitability(g.clone(), &mut p).nash_conv;
    // info!("alpha mu, open hand, m=1\t{}", e);

    // let mut p = AlphaMuBot::new(OpenHandSolver::new(), 32, 10, get_rng());
    // let e = exploitability(g, &mut p).nash_conv;
    // info!("alpha mu, open hand, m=10\t{}", e);

    // let mut agent = CFRAgent::new(
    //     g.clone(),
    //     42,
    //     MemoryNodeStore::default(),
    //     CFRAlgorithm::CFRCS,
    // );
    // agent.train(100_000);
    // let e = exploitability(g, &mut agent.ns).nash_conv;
    // info!("cfr\t{}", e);
}
